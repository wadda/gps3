Index: instance.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- instance.py	(revision 3eff3f6677fb13caf098dfc17f24c4887cfb081b)
+++ instance.py	(revision )
@@ -1,5 +1,7 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
+
+
 __author__ = 'wadda'
 # Pinched 2014
 # Created and re-created many times by a lot of different people over the last 14 years.
@@ -9,10 +11,10 @@
 from tempfile import gettempdir
 
 
-class singleInstance(object):
+class SingleInstance(object):
     def __init__(self):
         self.lockfile = os.path.normpath(gettempdir() + '/' + 'wadda.lock')
-        print self.lockfile
+        print((self.lockfile))
         self.single = True
         import fcntl
 
@@ -24,13 +26,13 @@
             self.single = False
             sys.exit('NxGPS is already running')
 
-
 if __name__ == '__main__':
     from time import sleep
 
-    lock = singleInstance()
+    lock = SingleInstance()
     if lock.single:
-        print 'single instance... running'
+        print('single instance... running')
         sleep(30)
+
     else:
-        print 'another instance is running... quitting'
+        print('another instance is running... quitting')
Index: waypoint.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- waypoint.py	(revision 3eff3f6677fb13caf098dfc17f24c4887cfb081b)
+++ waypoint.py	(revision )
@@ -9,7 +9,7 @@
 from pyproj import Geod  # sudo pip3 install pyproj
 from cmath import asin, sin
 import math
-# from math import radians, degrees
+from math import radians, degrees, cos
 # import gps3
 
 CONVERSION = {'imperial': 1609.344,
@@ -20,7 +20,7 @@
 
 EARTH_RADIUS = 6371009.0  # meters...It's a mean radius, but nice enough for crosstrack calculations
 
-geoid = Geod(ellps='WGS84')
+geoid = Geod(ellps='WGS84')  # See pyproj documentation for other fun options
 start_reference = ()
 endpoint = ()
 
@@ -101,6 +101,7 @@
 
         bearing_to, _, trip_distance = odometer(start, current)  # Distance A to C in meters
         a2c_radians = math.radians(bearing_to)  # radians are required in crosstrack calculations
+
         # Crosstrack calculations in radians, output as a complex numbers {'meters': (281.8893996162284+0j)
         crosstrack_distance['meters'] = (asin(sin(trip_distance['meters']) * sin(a2c_radians - a2b_radians))
                                          * EARTH_RADIUS)
@@ -112,7 +113,7 @@
         print("Can't calculate crosstrack because:", error)
         return None
 
-    distance = {k: v.real for k, v in crosstrack_distance.items()}  # extract 'real' number
+    distance = {unit: v.real for unit, v in crosstrack_distance.items()}  # extract 'real' number
 
     # Printing for testing
     print("ATCF Trip distance:", trip_distance)  # TODO: What to do with trip_distance?
@@ -123,50 +124,72 @@
     return distance
 
 
+class BestScenario(object):
-""" Hypothetical 'if' calculations for speculation, fairy tales, and general BS
-deceptively based on a few 'real world' inputs.  Variations on a theme requiring
-current position
+    """ Hypothetical 'if' calculations for speculation, fairy tales, and general BS
+    deceptively based on a few 'real world' inputs.  Variations on a theme requiring
+    current position
-current time
-current speed
-current course
+    current speed
+    current course
+    current time
-waypoint, distance and bearing
-"""
+    waypoint, distance and bearing
+    """
 
-
 def closest_approach():
     """ Present course will pass X distance from waypoint,
     or course required to maintain minimum distance  (inverse crosstrack)
+
+    hyp(distance_to) cos(avoid_distance)
+
     current position
     waypoint
     """
     raise NotImplementedError
 
 
-def eta():
-    """ ETA given present course and speed
-    waypoint distance and bearing
-    current speed
+def vmg():
+    """ Velocity Made Good given present course and speed
+    waypoint bearing
     current course
-    current time
+    current speed
     """
     raise NotImplementedError
 
 
-def shortest():
+
+
+def shortest(current, cog, end=None, units='meters'):
     """ Shortest distance to waypoint given present course
     waypoint distance and bearing
     current course
     """
-    raise NotImplementedError
+    distance_with_course = {}
 
+    try:
+        if not end:
+           end, _ = DEFAULT_START  # Picks Apataki
+        global endpoint
+        endpoint = end
+        bearing_to, bearing_fro, distance = odometer(current, end)  # Bearings, Distance C to D in meters
 
-def vmg():
-    """ Velocity Made Good given present course and speed
-    waypoint bearing
-    current course
-    current speed
-    """
-    raise NotImplementedError
+        c2d_radians = radians(bearing_to)
+        cog_radians = radians(cog)
+        course_delta = abs(cog_radians - c2d_radians)  # TODO: Is abs() required/desired?
+
+        distance_with_course['meters'] = (cos(course_delta) + sin(course_delta)) * distance['meters']
+
+        if units != 'meters':
+            shortest_distance[units] = distance_with_course['meters'] / CONVERSION[units]
+            trip_distance[units] = trip_distance['meters'] / CONVERSION[units]
+
+    except Exception as error:
+        print("Shortest distance cannot be calculated because:", error)
+        # return None
+
+    print('distance_with_course : ', distance_with_course, 'difference: ',
+    self.waypoint_distance_with_course - self.waypoint_distance)  # Test
+    # return
+
+
 
 
 def whentack():
Index: true_mag.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- true_mag.py	(revision 3eff3f6677fb13caf098dfc17f24c4887cfb081b)
+++ true_mag.py	(revision )
@@ -6,12 +6,7 @@
 from collections import deque
 from math import radians as radian, degrees
 import geomag
-
-# MINAVGMAX = [0.0, 0.0, 0.0]
-# CONVERSION = {'imperial': 2.2369363,
-# 'metric': 3.6,
-#               'nautical': 1.9438445}  # multiplication factors from m/s to units(hour)
-
+course = {}
 CARDINAL = ((011.25, 'N'), (033.75, 'NNE'), (056.25, 'NE'), (078.75, 'ENE'),
             (101.25, 'E'), (123.75, 'ESE'), (146.25, 'SE'), (168.75, 'SSE'),
             (191.25, 'S'), (213.75, 'SSW'), (236.25, 'SW'), (258.75, 'WSW'),
@@ -19,6 +14,28 @@
             (360.00, 'N'))
 
 
+def magdec(lat, lon):
+    """
+    current magnetic declination for location
+    Arguments:
+        :param lat: (float) Latitude
+        :param lon: (float) Longitude
+    Returns:
+        mag_dec: (dict) 'degrees': (float) Degrees Magnetic Declination
+                        'radians': (float) Magnetic Declination in Radians
+            mag_dec = {'degrees': 12.307940565271721, 'radians': 0.2148140870037636}
+
+    """
+    try:
+        mag_dec = {'degrees': geomag.declination(lat, lon)}
+        mag_dec['radians'] = radian(mag_dec['degrees'])  # radians
+        return mag_dec
+
+    except Exception as error:
+        print('Magnetic Declination is sick: ', error)
+        return None
+
+
 def magnetic_course(cog, mag_dec):
     """Course True and Magnetic with Cardinal points
     Arguments:
@@ -27,38 +44,17 @@
         :return:
             course (dict):  'true': (degree, cardinal), as (float, string) tuple
                             'magnetic': (degree, cardinal), as (float, string) tuple
+                course = {'true': (210, 'SSW'), 'magnetic': (222.34567, 'SW')}
     """
+    global course
     course = {'true': cog}
 
     course['magnetic'] = course['true'] + mag_dec
 
-    for key, value in course.items():
-        cardinal_index = (value + 11.25) // 22.5
-        cardinal_index = int(cardinal_index)
-        __, direction = CARDINAL[cardinal_index]
+    for key, value in course.items():  # magnetic or true
+        _index = (value + 11.25) // 22.5
+        _index = int(_index)
+        _, direction = CARDINAL[_index]
         course[key] = value, direction
     return course
 
-
-def magdec(lat, lon):
-    """
-    Magnetic Declination to write magdec to settings
-    Called with every configuration file write and every 24 hours of continous operation
-    :param lat:
-    :param lon:
-    """
-    try:
-        mag_dec = {'degrees': geomag.declination(lat, lon)}
-        mag_dec['radians'] = radian(mag_dec['degrees'])  # radians
-        return mag_dec
-
-    except Exception as error:
-        print('Magnetic Declination is sick: ', error)
-        return None
-
-        # >> > sog = {'meters': 12.317749248906763}
-        # >> > cog = {'true': 2.0197213650119394, 'radians': 0.035250787792332546}
-        # >> > minmax['low'] = sog
-        # >> > minmax
-        # {'low': {'meters': 12.317749248906763}}
-        # >> >
Index: odometer.py
===================================================================
--- odometer.py	(revision 3eff3f6677fb13caf098dfc17f24c4887cfb081b)
+++ odometer.py	(revision 3eff3f6677fb13caf098dfc17f24c4887cfb081b)
@@ -1,132 +0,0 @@
-#!/usr/bin/env python
-# -*- coding: utf-8 -*-
-""" odometer.py
-    A collection of distance and waypoint functions (2) for the NxGPS Project:
-    Getting the most out of a $30 gps, for Navigatrix (http://navigatrix.net)
-    NxGPS project repository is (https://github.com/wadda/NxGPS)
-"""
-from pyproj import Geod
-from cmath import asin, sin
-import math
-# from math import radians, degrees
-# import gps3
-
-conversion = {'nautical': 1852.0, 'imperial': 1609.344, 'metric': 1000.0, 'meters': 1.0}
-
-
-class Odometer(object):
-    """Odometer is a wrapper around pyproj.Geod distance calculations"""
-
-    def __init__(self):
-        self.bearing_to = None
-        self.bearing_fro = None
-        self.distance = {}
-
-    def do_to_fro_distance(self, lat1, lon1, lat2, lon2, units='meters'):
-        """lat lon from point A and point B, returns True North
-        bearings 'to', A-B(1-2), and 'fro', B-A (2-1) and distance in always
-        fashionable meters with optional nautical, imperial, or (kilo)metric"""
-        bearing_to = bearing_fro = self.distance['meters'] = None
-        try:
-            geoid = Geod(ellps='WGS84')
-            bearing_to, bearing_fro, self.distance['meters'] = geoid.inv(lon1, lat1, lon2, lat2)
-
-        except Exception as error:
-            print("Can't calculate to/fro because:", error)
-
-        finally:
-            if units not in 'meters':
-                self.distance[units] = self.distance['meters'] / conversion[units]
-
-            self.bearing_to = bearing_to % 360
-            self.bearing_fro = bearing_fro % 360
-
-        return self.bearing_to, self.bearing_fro, self.distance
-
-
-odometer = Odometer()
-
-
-class Waypoints(object):
-    def __init__(self):
-        self.startpoint_lat = None
-        self.startpoint_lon = None
-        self.a2b_radians = None
-        self.trip_distance = {}
-
-    def do_crosstrack(self, current_lat, current_lon, start_lat=None, start_lon=None,
-                      end_lat=None, end_lon=None, units='meters'):
-        """
-        return crosstrack distance from current position, and last set track or
-        return crosstrack distance from current position, start, and end positions
-
-        Formula from:
-        http: // williams.best.vwh.net / avform.htm  # XTE
-
-        """
-        default_lat = -15.560615  # Apataki Carenage
-        default_lon = -146.241122  # Apataki Carenage
-        default_a2b_radians = 4.2538533202126025  # bearing in radians Apataki to Kaputar
-        earth_radius = 6371009.0  # meters...It's a mean radius, but nice enough.
-        crosstrack_distance = {}
-
-        try:
-            if all([start_lon, start_lon, end_lat, end_lon]):  # both start and end shall start and end together.
-                # A to B
-                a2b_bearing, _, _ = odometer.do_to_fro_distance(start_lat, start_lon, end_lat, end_lon)
-                self.a2b_radians = math.radians(a2b_bearing)
-                self.startpoint_lat = start_lat
-                self.startpoint_lon = start_lon
-                # A to C
-            if not any([start_lat, start_lon, end_lat, end_lon]):
-                if not self.startpoint_lat:  # one is enough, or one is not enough, depending on perspective
-                    self.startpoint_lat = default_lat
-                    self.startpoint_lon = default_lon
-                    self.a2b_radians = default_a2b_radians
-                start_lat = self.startpoint_lat
-                start_lon = self.startpoint_lon
-
-            bearing_to, _, distance = odometer.do_to_fro_distance(start_lat, start_lon, current_lat, current_lon)
-            a2c_radians = math.radians(bearing_to)
-            self.trip_distance = distance
-            # Calculations in radians, output in complex numbers {'meters': (281.8893996162284+0j)
-            crosstrack_distance['meters'] = (asin(sin(distance['meters']) * sin(a2c_radians - self.a2b_radians))
-                                             * earth_radius)
-        except Exception as error:
-            print('Can\'t calculate crosstrack because: ', error)
-
-        finally:
-            if units not in 'meters':
-                crosstrack_distance[units] = crosstrack_distance['meters'] / conversion[units]
-            print('Positive should mean right of course, negative means left with the other choice.')
-
-            for k, v in crosstrack_distance.items():
-                print(k, ":", v.real)  # extract 'real' number
-
-            print("Scabed on xtrk trip distance:", self.trip_distance)
-
-            print('Real and imaginary in complex number:\n')
-
-        return crosstrack_distance
-
-
-waypoints = Waypoints()
-
-
-class BestSenario(object):
-    """Speculative calculations for conjecture and BS to"""
-    # WIP
-    pass
-
-    def eta(self):
-        pass
-
-    def vmg(self):
-        pass
-
-    def whentack(self):
-        pass
-
-    def shortest(self):
-        pass
-
Index: old_odometer.py
===================================================================
--- old_odometer.py	(revision 3eff3f6677fb13caf098dfc17f24c4887cfb081b)
+++ old_odometer.py	(revision 3eff3f6677fb13caf098dfc17f24c4887cfb081b)
@@ -1,149 +0,0 @@
-# -*- coding: utf-8 -*-
-
-"""Module that uses Starting Position, Current Position
-and pre-calculated bearing from SP to Waypoint"""
-from cmath import asin, sin
-from math import radians
-from pubsub import pub
-from pyproj import Geod
-import gps3
-import control
-
-settings = control.settings
-units = control.units
-
-
-class Odometer(object):
-    """Odometer and Cross Track Error"""
-
-    def __init__(self):
-        self.odometer_bearing = None
-        self.odometer_distance = None
-
-    def do_odometer(self, lat, lon):
-        """Start Point to current position distance"""
-        if not settings.show_odometer and not settings.show_crosstrack:
-            return
-
-        if isinstance(gps3.Fix.TPV['lat'], str):
-            return
-
-        if settings.startpoint_lat is None:
-            self.reset_startpoint()  # Does anything, or just get in the way?
-            return
-        try:
-            geoid = Geod(ellps='WGS84')
-            startpoint_lat = settings.startpoint_lat
-            startpoint_lon = settings.startpoint_lon
-            self.odometer_bearing, __, self.odometer_distance = geoid.inv(startpoint_lon, startpoint_lat, lon, lat)
-
-        except Exception as error:
-            print("Can't calculate odometer: ", error)
-
-        finally:
-            if settings.show_odometer:
-                odo_distance = self.odometer_distance
-                odo_distance *= units.DISTANCE[settings.distance_units]
-                pretty_odometer = '{0:.2f} {1}'.format(odo_distance, settings.distance_units)
-
-                pub.sendMessage('show_odometer', show_odometer=pretty_odometer)
-                print('Odometer:', pretty_odometer)
-
-            self.do_crosstrack()  # Call crosstrack()
-            return  # TODO: Add unsubscribe
-
-    def do_crosstrack(self):
-        """
-        http://williams.best.vwh.net/avform.htm#XTE
-
-        Cross track error:
-
-        Suppose you are proceeding on a great circle route from
-        A to B (course =crs_AB) and end up at D, perhaps off course.
-        (We presume that A is ot a pole!) You can calculate the
-        course from A to D (crs_AD) and the original_distance from A to
-        D (dist_AD) using the formulae above. In terms of these the cross track
-        error, XTD, (distance off course) is given by
-         crosstrack_distance = asin(sin(distancetravelled) * sin(coursetaken - courseintended))
-         XTD =asin(sin(dist_AD)*sin(crs_AD-crs_AB))
-
-        (positive XTD means right of course, negative means left)
-        (If the point A is the N. or S. Pole replace crs_AD-crs_AB with
-        lon_D-lon_B or lon_B-lon_D, respectively.)
-
-        The "along track distance", ATD, the distance from A along the
-        course towards B to the point abeam D is given by:
-
-                 ATD=acos(cos(dist_AD)/cos(XTD))
-
-        For very short distances:
-
-                 ATD=asin(sqrt( (sin(dist_AD))^2 - (sin(XTD))^2 )/cos(XTD))
-
-        is less susceptible to rounding error
-
-        Note that we can also use the above formulae to find the point of
-        closest approach to the point D on the great circle through A and B
-
-        Formula:
-        self.original_distance = 'distance' from StartPoint to Current Position
-        self.original_bearing = 'bearing' from StartPoint to Current Position
-        settings.startpoint_to_waypoint_bearing = 'origc' bearing from StartPoint to Waypoint
-        'earth_radius' is the earthâ€™s radius...it's big.
-
-        crosstrack_distance =asin(sin(original_distance)*sin(bearing - origc)) * earth_radius
-
-        (positive crosstrack_distance  means right of course, negative means left...we hope.)
-        """
-        if not settings.show_crosstrack:
-            return
-
-        if not settings.waypoint_lat:  # Should be unneccessary
-            print('Waypoint has not been set')  # TODO: Open waypoint dialogue
-            return
-
-        if not settings.startpoint_to_waypoint_bearing:
-            return
-
-        if not settings.startpoint_to_waypoint_distance:
-            return
-
-        pretty_crosstrack = None
-        if settings.startpoint_to_waypoint_bearing == float('Inf'):
-            return
-
-        try:
-            startpoint_to_waypoint_bearing = radians(settings.startpoint_to_waypoint_bearing)
-
-            earth_radius = 6371009.0  # meters...It's a mean radius, but nice enough.
-            odobearing = radians(self.odometer_bearing)
-            crosstrack_distance = (asin(sin(settings.startpoint_to_waypoint_distance) * sin(odobearing - startpoint_to_waypoint_bearing)) * earth_radius)
-
-            crosstrack_distance *= 1  # TODO: REPLACE units.DISTANCE[settings.distance_units]
-            pretty_crosstrack = '{0:2.1f} {1}'.format(crosstrack_distance, settings.distance_units)
-            print('-----------')
-            print(startpoint_to_waypoint_bearing)
-            print(odobearing)
-            print(crosstrack_distance)
-            print('mmmmmmmmmmmmm')
-
-        except Exception as error:
-            print('Can\'t calculate crosstrack because: ', error)
-            pretty_crosstrack = 'There be dragons.'
-
-        finally:
-            pub.sendMessage('crosstrack', show_crosstrack=pretty_crosstrack)
-            print('Cross Track: ', pretty_crosstrack)  # Test
-            return
-
-    @staticmethod
-    def reset_startpoint():
-        """set to None and re-fetch"""
-        settings.startpoint_lat = None
-        settings.startpoint_lon = None
-        settings.startpoint_to_waypoint_bearing = None
-        settings.startpoint_to_waypoint_distance = None
-        return
-
-
-odometer = Odometer()
Index: timestatus.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- timestatus.py	(revision 3eff3f6677fb13caf098dfc17f24c4887cfb081b)
+++ timestatus.py	(revision )
@@ -1,5 +1,7 @@
 #!/usr/bin/env python
 # -*- coding: utf-8 -*-
+
+
 """Time stuff"""
 from time import time
 from datetime import datetime
@@ -43,7 +45,7 @@
             return
         else:
             self.gpstime = dateutil.parser.parse(utc)  # Become datetime object
-            print type(self.today), type(self.gpstime)
+            print(type(self.today), type(self.gpstime))
             if not self.today or self.today <= self.gpstime:  # So we can do this comparison
                 latlon.do_latlon.magdec()  # TODO: Remember to add ui events for this function
                 deltatee = dateutil.tz.tzlocal()
@@ -69,7 +71,7 @@
         if self.gpstime is None:  # Shouldn't ever happen (unnecessary?)
             pretty_time = "No Data"
             pub.sendMessage('show_time', show_time=pretty_time)
-            print 'ND Time: ', pretty_time
+            print('NoData Time: ', pretty_time)
             return
 
         shiptime = self.gpstime
@@ -100,7 +102,7 @@
 
         finally:
             pub.sendMessage('show_time', show_time=pretty_time)
-            print 'Time: ', pretty_time  # Test
+            print('Time: ', pretty_time)  # Test
 
         return
 
@@ -116,7 +118,7 @@
         if self.gpstime is None:  # Shouldn't ever happen...should it.
             pretty_date = "Ooops"
             pub.sendMessage('show_date', show_date=pretty_date)
-            print 'Date: ', pretty_date  # Test
+            print('Date: ', pretty_date)  # Test
             return
 
         shiptime = self.gpstime
@@ -138,12 +140,12 @@
                 pretty_date = shiptime.strftime('%A, %b %d, %Y')
 
         except Exception as error:
-            pretty_date = error
-            print 'Date error :', error
+            pretty_date = "bRo-KeN"
+            print('Date error :', error)
 
         finally:
             pub.sendMessage('show_date', show_date=pretty_date)
-            print 'Date: ', pretty_date
+            print('Date: ', pretty_date)
             return
 
 
@@ -181,7 +183,7 @@
             pretty_sats = '{} of {}'.format(sats_used, sats_inview)
 
         pub.sendMessage('show_quality', show_mode=pretty_mode, show_usedinview=pretty_sats)
-        print 'Quality: ', pretty_mode, 'using', pretty_sats, 'satellites in view'  # Test
+        print('Quality: ', pretty_mode, 'using', pretty_sats, 'satellites in view')  # Test
         return
 
 timestatus = TimeStatus()
@@ -199,6 +201,7 @@
             return
 
         pretty_elapsed = None
+        time_delta = None
         try:
             time_now = time()
             time_delta = time_now - settings.time_beginning
@@ -222,7 +225,7 @@
 
         finally:
             pub.sendMessage('show_elapsed', show_elapsed=pretty_elapsed)
-            print 'Elapsed Time: ', pretty_elapsed, 'timedelta: ', time_delta
+            print('Elapsed Time: ', pretty_elapsed, 'timedelta: ', time_delta)
 
             return
 
@@ -248,3 +251,8 @@
         return
 
 misc = Misc()
+
+    actionList = []
+    for k in gameState.getLegalActions(agentIndex):
+        actionList.append((self.miniMaxHelp(gameState.generateSuccessor(agentIndex, k),
+                                            newDepth, ind)[0], k))
